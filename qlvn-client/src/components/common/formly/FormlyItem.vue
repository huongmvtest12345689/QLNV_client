<template>
    <div :class="[{
      'is-error': validateState === 'error',
    }]">
        <slot></slot>
        <transition name="el-zoom-in-top">
            <slot
                    v-if="validateState === 'error'"
                    name="error"
                    :error="validateMessage">
                <small> {{validateMessage}}</small>
            </slot>
        </transition>
    </div>
</template>
<script>
    import AsyncValidator from 'async-validator';
    import emitter from 'element-ui/src/mixins/emitter';
    import objectAssign from 'element-ui/src/utils/merge';
    import {noop, getPropByPath} from 'element-ui/src/utils/util';

    export default {
        name: 'FormlyItem',

        componentName: 'FormlyItem',

        mixins: [emitter],

        provide() {
            return {
                formlyItem: this
            };
        },

        inject: ['formly'],

        props: {
            label: String,
            labelWidth: String,
            prop: String,
            required: {
                type: Boolean,
                default: undefined
            },
            rules: [Object, Array],
            error: String,
            validateStatus: String,
            for: String,
            inlineMessage: {
                type: [String, Boolean],
                default: ''
            },
            showMessage: {
                type: Boolean,
                default: true
            },
            size: String
        },
        watch: {
            error: {
                immediate: true,
                handler(value) {
                    this.validateMessage = value;
                    this.validateState = value ? 'error' : '';
                }
            },
            validateStatus(value) {
                this.validateState = value;
            }
        },
        computed: {
            fieldValue() {
                const model = this.form.model;
                if (!model || !this.prop) {
                    return;
                }

                let path = this.prop;
                if (path.indexOf(':') !== -1) {
                    path = path.replace(/:/, '.');
                }

                return getPropByPath(model, path, true).v;
            },
            isRequired() {
                let rules = this.getRules();
                let isRequired = false;

                if (rules && rules.length) {
                    rules.every(rule => {
                        if (rule.required) {
                            isRequired = true;
                            return false;
                        }
                        return true;
                    });
                }
                return isRequired;
            },
            _formSize() {
                return this.formly.size;
            },
            elFormItemSize() {
                return this.size || this._formSize;
            },
            sizeClass() {
                return this.elFormItemSize || (this.$ELEMENT || {}).size;
            }
        },
        data() {
            return {
                validateState: '',
                validateMessage: '',
                validateDisabled: false,
                validator: {},
                isNested: false,
                computedLabelWidth: ''
            };
        },
        methods: {
            validate(trigger, callback = noop) {
                this.validateDisabled = false;
                const rules = this.getFilteredRule(trigger);
                if ((!rules || rules.length === 0) && this.required === undefined) {
                    callback();
                    return true;
                }

                this.validateState = 'validating';

                const descriptor = {};
                if (rules && rules.length > 0) {
                    rules.forEach(rule => {
                        delete rule.trigger;
                    });
                }
                descriptor[this.prop] = rules;

                const validator = new AsyncValidator(descriptor);
                const model = {};

                model[this.prop] = this.fieldValue;

                validator.validate(model, {firstFields: true}, (errors, invalidFields) => {
                    this.validateState = !errors ? 'success' : 'error';
                    this.validateMessage = errors ? errors[0].message : '';

                    callback(this.validateMessage, invalidFields);
                    this.formly && this.formly.$emit('validate', this.prop, !errors, this.validateMessage || null);
                });
            },
            clearValidate() {
                this.validateState = '';
                this.validateMessage = '';
                this.validateDisabled = false;
            },
            resetField() {
                this.validateState = '';
                this.validateMessage = '';

                let model = this.form.model;
                let value = this.fieldValue;
                let path = this.prop;
                if (path.indexOf(':') !== -1) {
                    path = path.replace(/:/, '.');
                }

                let prop = getPropByPath(model, path, true);

                this.validateDisabled = true;
                if (Array.isArray(value)) {
                    prop.o[prop.k] = [].concat(this.initialValue);
                } else {
                    prop.o[prop.k] = this.initialValue;
                }

                // reset validateDisabled after onFieldChange triggered
                this.$nextTick(() => {
                    this.validateDisabled = false;
                });

                this.broadcast('ElTimeSelect', 'fieldReset', this.initialValue);
            },
            getRules() {
                let formRules = this.form.rules;
                const selfRules = this.rules;
                const requiredRule = this.required !== undefined ? {required: !!this.required} : [];

                const prop = getPropByPath(formRules, this.prop || '');
                formRules = formRules ? (prop.o[this.prop || ''] || prop.v) : [];

                return [].concat(selfRules || formRules || []).concat(requiredRule);
            },
            getFilteredRule(trigger) {
                const rules = this.getRules();

                return rules.filter(rule => {
                    if (!rule.trigger || trigger === '') return true;
                    if (Array.isArray(rule.trigger)) {
                        return rule.trigger.indexOf(trigger) > -1;
                    } else {
                        return rule.trigger === trigger;
                    }
                }).map(rule => objectAssign({}, rule));
            },
            onFieldBlur() {
                this.validate('blur');
            },
            onFieldChange() {
                if (this.validateDisabled) {
                    this.validateDisabled = false;
                    return;
                }

                this.validate('change');
            },
            updateComputedLabelWidth(width) {
                this.computedLabelWidth = width ? `${width}px` : '';
            },
            addValidateEvents() {
                const rules = this.getRules();

                if (rules.length || this.required !== undefined) {
                    this.$on('blur', this.onFieldBlur);
                    this.$on('item-select', this.onFieldChange);
                    this.$on('change', this.onFieldChange);
                    this.$on('date-select', this.onFieldChange);
                }
            },
            removeValidateEvents() {
                this.$off();
            }
        },
        mounted() {
            if (this.prop) {
                this.dispatch('formly', 'el.form.addField', [this]);

                let initialValue = this.fieldValue;
                if (Array.isArray(initialValue)) {
                    initialValue = [].concat(initialValue);
                }
                Object.defineProperty(this, 'initialValue', {
                    value: initialValue
                });

                this.addValidateEvents();
            }
        },
        beforeDestroy() {
            this.dispatch('formly', 'el.form.removeField', [this]);
        }
    };
</script>
